From 0d8e4ef85b42d3d2a8ac8d5b266e63a810b8f1b2 Mon Sep 17 00:00:00 2001
From: Codex <codex@openai.com>
Date: Fri, 13 Feb 2026 09:20:00 +0000
Subject: [PATCH] net: dsa: yt921x: add SerDes mode override and debug register dumps

Add two opt-in DT controls for faster bring-up experiments on YT921x
external CPU links:

- `motorcomm,serdes-mode`: force the internal SerDes mode selection
  (`sgmii`, `revsgmii`, `1000base-x`, `2500base-x`, ...)
- `motorcomm,debug-port-regs`: print key per-port/link registers after
  `mac_config` and `mac_link_up`

Default behavior is unchanged when these properties are not present.
The existing SGMII->REVSGMII mapping stays as default.

Signed-off-by: Codex <codex@openai.com>
---
--- a/drivers/net/dsa/yt921x.c
+++ b/drivers/net/dsa/yt921x.c
@@ -158,6 +158,8 @@
 #define YT921X_POLL_SLEEP_US	10000
 #define YT921X_POLL_TIMEOUT_US	100000
 
+#define YT921X_SERDES_MODE_AUTO	(-1)
+
 /* The interval should be small enough to avoid overflow of 32bit MIBs.
  *
  * Until we can read MIBs from stats64 call directly (i.e. sleep
@@ -186,6 +188,114 @@
 #define to_yt921x_priv(_ds) container_of_const(_ds, struct yt921x_priv, ds)
 #define to_device(priv) ((priv)->ds.dev)
 
+static int yt921x_reg_read(struct yt921x_priv *priv, u32 reg, u32 *valp);
+
+static const char *yt921x_serdes_mode_name(int mode)
+{
+	if (mode == YT921X_SERDES_MODE_AUTO)
+		return "auto";
+	if (mode == YT921X_SERDES_MODE_SGMII)
+		return "sgmii";
+	if (mode == YT921X_SERDES_MODE_REVSGMII)
+		return "revsgmii";
+	if (mode == YT921X_SERDES_MODE_100BASEX)
+		return "100base-x";
+	if (mode == YT921X_SERDES_MODE_1000BASEX)
+		return "1000base-x";
+	if (mode == YT921X_SERDES_MODE_2500BASEX)
+		return "2500base-x";
+	return "unknown";
+}
+
+static int
+yt921x_serdes_mode_parse(struct device *dev, int port, struct device_node *dn,
+			 int *modep)
+{
+	const char *mode;
+
+	*modep = YT921X_SERDES_MODE_AUTO;
+	if (!dn || of_property_read_string(dn, "motorcomm,serdes-mode", &mode))
+		return 0;
+
+	if (!strcmp(mode, "auto")) {
+		*modep = YT921X_SERDES_MODE_AUTO;
+	} else if (!strcmp(mode, "sgmii") || !strcmp(mode, "hsgmii")) {
+		*modep = YT921X_SERDES_MODE_SGMII;
+	} else if (!strcmp(mode, "revsgmii") || !strcmp(mode, "rev-sgmii")) {
+		*modep = YT921X_SERDES_MODE_REVSGMII;
+	} else if (!strcmp(mode, "100base-x")) {
+		*modep = YT921X_SERDES_MODE_100BASEX;
+	} else if (!strcmp(mode, "1000base-x")) {
+		*modep = YT921X_SERDES_MODE_1000BASEX;
+	} else if (!strcmp(mode, "2500base-x")) {
+		*modep = YT921X_SERDES_MODE_2500BASEX;
+	} else {
+		dev_err(dev,
+			"Unsupported motorcomm,serdes-mode \"%s\" on port %d\n",
+			mode, port);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static void
+yt921x_port_dump_regs(struct yt921x_priv *priv, int port, const char *where)
+{
+	struct yt921x_port *pp = &priv->ports[port];
+	struct device *dev = to_device(priv);
+	u32 port_ctrl;
+	u32 port_status;
+	u32 serdes_ctrl;
+	u32 xmii_ctrl;
+	u32 serdes;
+	u32 xmii;
+	u32 mdio_poll;
+	int res;
+
+	if (!pp->debug_port_regs)
+		return;
+
+	res = yt921x_reg_read(priv, YT921X_PORTn_CTRL(port), &port_ctrl);
+	if (res)
+		goto out_err;
+	res = yt921x_reg_read(priv, YT921X_PORTn_STATUS(port), &port_status);
+	if (res)
+		goto out_err;
+
+	if (!yt921x_port_is_external(port)) {
+		dev_info(dev, "port %d %s: PORT_CTRL=0x%08x PORT_STATUS=0x%08x\n",
+			 port, where, port_ctrl, port_status);
+		return;
+	}
+
+	res = yt921x_reg_read(priv, YT921X_SERDES_CTRL, &serdes_ctrl);
+	if (res)
+		goto out_err;
+	res = yt921x_reg_read(priv, YT921X_XMII_CTRL, &xmii_ctrl);
+	if (res)
+		goto out_err;
+	res = yt921x_reg_read(priv, YT921X_SERDESn(port), &serdes);
+	if (res)
+		goto out_err;
+	res = yt921x_reg_read(priv, YT921X_XMIIn(port), &xmii);
+	if (res)
+		goto out_err;
+	res = yt921x_reg_read(priv, YT921X_MDIO_POLLINGn(port), &mdio_poll);
+	if (res)
+		goto out_err;
+
+	dev_info(dev,
+		 "port %d %s: PORT_CTRL=0x%08x PORT_STATUS=0x%08x SERDES_CTRL=0x%08x XMII_CTRL=0x%08x SERDES=0x%08x XMII=0x%08x MDIO_POLL=0x%08x\n",
+		 port, where, port_ctrl, port_status, serdes_ctrl, xmii_ctrl,
+		 serdes, xmii, mdio_poll);
+	return;
+
+out_err:
+	dev_warn(dev, "port %d %s: register dump failed: %d\n",
+		 port, where, res);
+}
+
 static int yt921x_reg_read(struct yt921x_priv *priv, u32 reg, u32 *valp)
 {
 	WARN_ON(!mutex_is_locked(&priv->reg_lock));
@@ -2236,6 +2346,8 @@
 			return res;
 	}
 
+	yt921x_port_dump_regs(priv, port, "port_up");
+
 	return 0;
 }
 
@@ -2243,7 +2355,9 @@
 yt921x_port_config(struct yt921x_priv *priv, int port, unsigned int mode,
 		   phy_interface_t interface)
 {
+	struct yt921x_port *pp = &priv->ports[port];
 	struct device *dev = to_device(priv);
+	bool serdes = false;
 	u32 mask;
 	u32 ctrl;
 	int res;
@@ -2258,22 +2372,36 @@
 	}
 
 	switch (interface) {
-	/* SERDES */
 	case PHY_INTERFACE_MODE_SGMII:
 	case PHY_INTERFACE_MODE_100BASEX:
 	case PHY_INTERFACE_MODE_1000BASEX:
 	case PHY_INTERFACE_MODE_2500BASEX:
-		mask = YT921X_SERDES_CTRL_PORTn(port);
-		res = yt921x_reg_set_bits(priv, YT921X_SERDES_CTRL, mask);
-		if (res)
-			return res;
+		serdes = true;
+		break;
+	default:
+		break;
+	}
 
-		mask = YT921X_XMII_CTRL_PORTn(port);
-		res = yt921x_reg_clear_bits(priv, YT921X_XMII_CTRL, mask);
-		if (res)
-			return res;
+	if (pp->serdes_mode != YT921X_SERDES_MODE_AUTO)
+		serdes = true;
+
+	if (!serdes)
+		return -EINVAL;
+
+	mask = YT921X_SERDES_CTRL_PORTn(port);
+	res = yt921x_reg_set_bits(priv, YT921X_SERDES_CTRL, mask);
+	if (res)
+		return res;
 
-		mask = YT921X_SERDES_MODE_M;
+	mask = YT921X_XMII_CTRL_PORTn(port);
+	res = yt921x_reg_clear_bits(priv, YT921X_XMII_CTRL, mask);
+	if (res)
+		return res;
+
+	mask = YT921X_SERDES_MODE_M;
+	if (pp->serdes_mode != YT921X_SERDES_MODE_AUTO) {
+		ctrl = pp->serdes_mode;
+	} else {
 		switch (interface) {
 		case PHY_INTERFACE_MODE_SGMII:
 			/* abuse SGMII for REVSGMII */
@@ -2291,17 +2419,14 @@
 		default:
 			return -EINVAL;
 		}
-		res = yt921x_reg_update_bits(priv, YT921X_SERDESn(port),
-					     mask, ctrl);
-		if (res)
-			return res;
-
-		break;
-	/* add XMII support here */
-	default:
-		return -EINVAL;
 	}
 
+	res = yt921x_reg_update_bits(priv, YT921X_SERDESn(port), mask, ctrl);
+	if (res)
+		return res;
+
+	yt921x_port_dump_regs(priv, port, "port_config");
+
 	return 0;
 }
 
@@ -2462,8 +2587,28 @@
 static int yt921x_dsa_port_setup(struct dsa_switch *ds, int port)
 {
 	struct yt921x_priv *priv = to_yt921x_priv(ds);
+	struct yt921x_port *pp = &priv->ports[port];
+	struct device *dev = to_device(priv);
+	struct dsa_port *dp = dsa_to_port(ds, port);
+	struct device_node *dn = dp->dn;
+	int serdes_mode;
 	int res;
 
+	pp->debug_port_regs = dn &&
+			      of_property_read_bool(dn, "motorcomm,debug-port-regs");
+	res = yt921x_serdes_mode_parse(dev, port, dn, &serdes_mode);
+	if (res)
+		return res;
+	pp->serdes_mode = serdes_mode;
+
+	if (pp->serdes_mode != YT921X_SERDES_MODE_AUTO)
+		dev_info(dev, "port %d: motorcomm,serdes-mode=%s\n", port,
+			 yt921x_serdes_mode_name(pp->serdes_mode));
+
+	if (pp->debug_port_regs)
+		dev_info(dev, "port %d: motorcomm,debug-port-regs enabled\n",
+			 port);
+
 	mutex_lock(&priv->reg_lock);
 	res = yt921x_port_setup(priv, port);
 	mutex_unlock(&priv->reg_lock);
@@ -2853,6 +2998,7 @@
 		struct yt921x_port *pp = &priv->ports[i];
 
 		pp->index = i;
+		pp->serdes_mode = YT921X_SERDES_MODE_AUTO;
 		INIT_DELAYED_WORK(&pp->mib_read, yt921x_poll_mib);
 	}
 
--- a/drivers/net/dsa/yt921x.h
+++ b/drivers/net/dsa/yt921x.h
@@ -465,9 +465,11 @@
 
 struct yt921x_port {
 	unsigned char index;
+	int serdes_mode;
 
 	bool hairpin;
 	bool isolated;
+	bool debug_port_regs;
 
 	struct delayed_work mib_read;
 	struct yt921x_mib mib;
